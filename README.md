# [Coding Interview Preparation by Meta](https://www.coursera.org/learn/coding-interview-preparation/home/week/1)
part of Meta Back-End Developer Specialization  

### Week 1. Introduction to the coding interview

Video: Binary  
Reading: Working in binary  
Video: Memory  
Reading: Defining solutions  
Video: Time complexity  
Reading: Working with time complexity  
Practice Quiz: Knowledge check: Time complexity  
Video: Space complexity  
Practice Quiz: Knowledge check: Space complexity  
Video: Module summary: Introduction to the coding interview  


### Week 2. Introduction to Data Structures
Video: Basic data structures  
Reading: Strings  
Reading: Integers  
Reading: Booleans  
Reading: Arrays  
Reading: Objects  
Practice Quiz: Knowledge check: Basic data structures  
Reading: Additional resources  
Video: Lists and sets  
Reading: Lists and sets in different programming languages  
Video: Stacks and queues  
Reading: Stacks and queues in different programming languages  
Video: Trees  
Reading: Trees in different programming languages  
Practice Quiz: Knowledge check: Collection data structures  
Reading: Additional resources  
Video: Hash tables  
Reading: Hash tables in different programming languages  
Video: Heaps  
Video: Graphs  
Reading: Heaps and graphs in different programming languages  
Practice Quiz: Knowledge check: Advanced data structures  
Video: Module summary: Introduction to data structures  

### Week 3. Introduction to Algorithms  
Video: Sorting Algorithms  
Reading: Time and space complexity in sorting algorithms  
Video: Searching Algorithms  
Reading: Time and space complexity in search algorithms  
Practice Quiz: Knowledge check: Sorting and searching  
Reading: Additional resources  
Video: Divide and conquer  
Video: Recursion  
Video: Dynamic programming  
Video: Greedy algorithms  
Discussion Prompt: Where can you use algorithms?  
Practice Quiz: Knowledge check: Working with algorithms  



### Week 4. wrapup 

# Data Structures and Algorithms Specialization

# Course 1. [Algorithmic Toolbox](https://www.coursera.org/learn/algorithmic-toolbox/home/week/6)
 
  sorting and searching, divide and conquer, greedy algorithms, dynamic programming. We will learn a lot of theory: how to sort data and how it helps for searching; how to break a large problem into pieces and solve them recursively; when it makes sense to proceed greedily; how dynamic programming is used in genomic studies. You will practice solving computational problems, designing new algorithms, and implementing solutions efficiently (so that they run in less than a second).

### Week 1. Programming Challenges
Solving the Sum of Two Digits Programming Challenge (screencast)  
Solving the Maximum Pairwise Product Programming Challenge: Improving the Naive Solution, Testing, Debugging  
Stress Test - Implementation  
Stress Test - Find the Test and Debug  
Stress Test - More Testing, Submit and Pass  

Programming Assignment: Programming Assignment 1: Maximum Pairwise Product

### Week 2. Algorithmic Warm-up
Why Study Algorithms?  
Coming Up  
Problem Overview  
Naive Algorithm  
Efficient Algorithm  
Problem Overview and Naive Algorithm  
Efficient Algorithm  
Computing Runtimes  
Asymptotic Notation  
Big-O Notation  
Using Big-O   

Practice exercises
Logarithms  
Big-O  
Growth rate  

Programming Assignment: Programming Assignment 2: Algorithmic Warm-up

### Week 3. Greedy Algorithms

Largest Number  
Queue of Patients  
Implementation and Analysis  
Main Ingredients of Greedy Algorithms  
Celebration Party Problem  
Greedy Algorithm  
Implementation and Analysis  
Maximizing Loot  
Implementation and Analysis  
 

practice exercises  
Largest Concatenate  
Money Change  
Puzzle: Balls in boxes  
Puzzle: Activity Selection  
Puzzle: Touch All Segments  

Programming Assignment: Programming Assignment 3: Greedy Algorithms



### Week 4. Divide-and-Conquer
Linear Search  
Binary Search  
Binary Search Runtime  
Problem Overview and Naïve Solution  
Naïve Divide and Conquer Algorithm  
Faster Divide and Conquer Algorithm  
What is the Master Theorem?  
Proof of the Master Theorem  
Problem Overview  
Selection Sort  
Merge Sort  
Lower Bound for Comparison Based Sorting  
Non-Comparison Based Sorting Algorithm  
 
Algorithm  
Random Pivot  
Running Time Analysis (optional)  
Equal Elements   

practice exercises
Linear Search and Binary Search  
Puzzle: 21 questions game  
Puzzle: Two Adjacent Cells of Opposite Colors  
Polynomial Multiplication  
Master Theorem  
Sorting  
Quick Sort  
Puzzle: Local Maximum  

Programming Assignment: Programming Assignment 4: Divide and Conquer


### Week 5. Dynamic Programming 1
Change Problem  
The Alignment Game  
Computing Edit Distance  
Reconstructing an Optimal Alignment  

practice exercises
Change Money  
Puzzle: Number of Paths  
Puzzle: Two Rocks Game  
Puzzle: Three Rocks Game  
Edit Distance  
Puzzle: Primitive Calculator  

Programming Assignment: Programming Assignment 5: Dynamic Programming 1

### Week 6. Dynamic Programming 2
Knapsack with Repetitions  
Knapsack without Repetitions  
Final Remarks  
Problem Overview  
Subproblems  
Algorithm  
Reconstructing a Solution  

practice exercises  
Knapsack    
Maximum Value of an Arithmetic Expression  

Programming Assignment: Programming Assignment 6: Dynamic Programming 2

# Course 2. [Data Structures](https://www.coursera.org/learn/data-structures/home/week/1)

A good algorithm usually comes together with a set of good data structures that allow the algorithm to manipulate the data efficiently. In this online course, we consider the common data structures that are used in various computational problems. You will learn how these data structures are implemented in different programming languages and will practice implementing them in our programming assignments. This will help you to understand what is going on inside a particular built-in implementation of a data structure and what to expect from it. You will also learn typical use cases for these data structures.

A few examples of questions that we are going to cover in this class are the following:
1. What is a good strategy of resizing a dynamic array?
2. How priority queues are implemented in C++, Java, and Python?
3. How to implement a hash table so that the amortized running time of all operations is O(1) on average?
4. What are good strategies to keep a binary tree balanced? 

You will also learn how services like Dropbox manage to upload some large files instantly and to save a lot of storage space!

### Week 1. Basic Data Structures  
Video: Arrays  
Video: Singly-Linked Lists  
Video: Doubly-Linked Lists  
Reading: Slides and External References  
Video: Stacks  
Video: Queues  
Reading: Slides and External References  
Video: Trees  
Video: Tree Traversal  
Reading: Slides and External References  
Practice Quiz: Basic Data Structures  
Reading: Available Programming Languages  
Reading: FAQ on Programming Assignments  
Reading: Acknowledgements  

Graded: Programming Assignment 1: Basic Data Structures  

### Week 2. Dynamic Arrays and Amortized Analysis

Video: Dynamic Arrays  
Video: Amortized Analysis: Aggregate Method  
Video: Amortized Analysis: Banker's Method  
Video: Amortized Analysis: Physicist's Method  
Video: Amortized Analysis: Summary  
Reading: Slides and External References  

Graded: Dynamic Arrays and Amortized Analysis  

### Week 3. Priority Queues and Disjoint Sets  

Video: Introduction  
Video: Naive Implementations of Priority Queues  
Reading: Slides  
Video: Binary Trees  
Reading: Tree Height Remark  
Video: Basic Operations  
Video: Complete Binary Trees  
Video: Pseudocode  
Reading: Slides and External References  
Video: Heap Sort  
Video: Building a Heap  
Video: Final Remarks  
Reading: Slides and External References  
Video: Overview  
Video: Naive Implementations  
Reading: Slides and External References  
Video: Trees for Disjoint Sets  
Video: Union by Rank  
Video: Path Compression  
Video: Analysis (Optional)  
Reading: Slides and External References  
Practice Quiz: Priority Queues and Disjoint Sets  
Ungraded Plugin: Survey  

Graded: Priority Queues: Quiz  
Graded: Quiz: Disjoint Sets  
Graded: Programming Assignment 2: Priority Queues and Disjoint Sets  


### Week 4. Hash Tables

Video: Applications of Hashing  
Video: Analysing Service Access Logs  
Video: Direct Addressing  
Video: Hash Functions  
Video: Chaining  
Video: Chaining Implementation and Analysis  
Video: Hash Tables  
Reading: Slides and External References  
Video: Phone Book Data Structure  
Video: Universal Family  
Video: Hashing Phone Numbers  
Video: Hashing Names  
Video: Analysis of Polynomial Hashing  
Reading: Slides and External References  
Video: Find Substring in Text  
Video: Rabin-Karp's Algorithm  
Video: Recurrence for Substring Hashes  
Video: Improving Running Time  
Reading: Slides and External References  
Video: Julia's Diary  
Video: Julia's Bank  
Video: Blockchain  
Video: Merkle Tree  
Reading: Slides and External References  
Practice Quiz: Hashing  

Graded: Hash Tables and Hash Functions  
Graded: Programming Assignment 3: Hash Tables  


### Week 5. Binary Search Trees

Video: Introduction  
Video: Search Trees  
Video: Basic Operations  
Video: Balance  
Reading: Slides and External References  
Video: AVL Trees  
Video: AVL Tree Implementation  
Video: Split and Merge  
Reading: Slides and External References  
Practice Quiz: Binary Search Trees  

### Week 6. Binary Search Trees 2

Video: Applications  
Reading: Slides and External References  
Video: Splay Trees: Introduction   
Video: Splay Trees: Implementation  
Video: (Optional) Splay Trees: Analysis  
Reading: Slides and External References  
Practice Quiz: Splay Trees  

Graded: Programming Assignment 4: Binary Search Trees  

# Course 3. [Algorithms on Graphs](https://www.coursera.org/learn/algorithms-on-graphs/home/week/1)

If you have ever used a navigation service to find optimal route and estimate time to destination, you've used algorithms on graphs. Graphs arise in various real-world situations as there are road networks, computer networks and, most recently, social networks! If you're looking for the fastest time to get to work, cheapest way to connect a set of computers into a network or efficient algorithm to automatically find communities and opinion leaders in Facebook, you're going to work with graphs and algorithms on graphs.

In this online course, you will first learn what a graph is and what are some of the most important properties. Then you'll learn several ways to traverse graphs and how you can do useful things while traversing the graph in some order. We will then talk about shortest paths algorithms — from the basic ones to those which open door for 1000000 times faster algorithms used in Google Maps and other navigational services. You will use these algorithms if you choose to work on our Fast Shortest Routes industrial capstone project. We will finish with minimum spanning trees which are used to plan road, telephone and computer networks and also find applications in clustering and approximate algorithms.

### Week 1.

### Week 2.

### Week 3.

### Week 4.

# Course 4. [Algorithms on Strings](https://www.coursera.org/learn/algorithms-on-strings/home/week/1)

World and internet is full of textual information. We search for information using textual queries, we read websites, books, e-mails. All those are strings from the point of view of computer science. To make sense of all that information and make search efficient, search engines use many string algorithms. Moreover, the emerging field of personalized medicine uses many search algorithms to find disease-causing mutations in the human genome. In this online course you will learn key pattern matching concepts: tries, suffix trees, suffix arrays and even the Burrows-Wheeler transform.

### Week 1.

### Week 2.

### Week 3.

### Week 4.


# Course 5. [Advanced Algorithms and Complexity](https://www.coursera.org/learn/advanced-algorithms-and-complexity/home/week/1)

In previous courses of our online specialization you've learned the basic algorithms, and now you are ready to step into the area of more complex problems and algorithms to solve them. Advanced algorithms build upon basic ones and use new ideas. We will start with networks flows which are used in more typical applications such as optimal matchings, finding disjoint paths and flight scheduling as well as more surprising ones like image segmentation in computer vision. We then proceed to linear programming with applications in optimizing budget allocation, portfolio optimization, finding the cheapest diet satisfying all requirements and many others. Next we discuss inherently hard problems for which no exact good solutions are known (and not likely to be found) and how to solve them in practice. We finish with a soft introduction to streaming algorithms that are heavily used in Big Data processing. Such algorithms are usually designed to be able to process huge datasets without being able even to store a dataset.

### Week 1.

### Week 2.

### Week 3.

### Week 4.


# Course 6. [Genome Assembly Programming Challenge](https://www.coursera.org/learn/assembling-genomes/home/week/1)

In Spring 2011, thousands of people in Germany were hospitalized with a deadly disease that started as food poisoning with bloody diarrhea and often led to kidney failure. It was the beginning of the deadliest outbreak in recent history, caused by a mysterious bacterial strain that we will refer to as E. coli X. Soon, German officials linked the outbreak to a restaurant in Lübeck, where nearly 20% of the patrons had developed bloody diarrhea in a single week. At this point, biologists knew that they were facing a previously unknown pathogen and that traditional methods would not suffice – computational biologists would be needed to assemble and analyze the genome of the newly emerged pathogen.

To investigate the evolutionary origin and pathogenic potential of the outbreak strain, researchers started a crowdsourced research program. They released bacterial DNA sequencing data from one of a patient, which elicited a burst of analyses carried out by computational biologists on four continents. They even used GitHub for the project: https://github.com/ehec-outbreak-crowdsourced/BGI-data-analysis/wiki

The 2011 German outbreak represented an early example of epidemiologists collaborating with computational biologists to stop an outbreak. In this online course you will follow in the footsteps of the bioinformaticians investigating the outbreak by developing a program to assemble the genome of the E. coli X from millions of overlapping substrings of the E.coli X genome.


### Week 1.

### Week 2.

### Week 3.

### Week 4.