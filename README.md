# Data Structures and Algorithms Specialization

# Course 1. [Algorithmic Toolbox](https://www.coursera.org/learn/algorithmic-toolbox/home/week/6)
 
  sorting and searching, divide and conquer, greedy algorithms, dynamic programming. We will learn a lot of theory: how to sort data and how it helps for searching; how to break a large problem into pieces and solve them recursively; when it makes sense to proceed greedily; how dynamic programming is used in genomic studies. You will practice solving computational problems, designing new algorithms, and implementing solutions efficiently (so that they run in less than a second).

### Week 1. Programming Challenges
Solving the Sum of Two Digits Programming Challenge (screencast)6m
Solving the Maximum Pairwise Product Programming Challenge: Improving the Naive Solution, Testing, Debugging13m
Stress Test - Implementation8m
Stress Test - Find the Test and Debug7m
Stress Test - More Testing, Submit and Pass!8m

Programming Assignment: Programming Assignment 1: Maximum Pairwise Product

### Week 2. Algorithmic Warm-up
Why Study Algorithms?7m
Coming Up3m
Problem Overview3m
Naive Algorithm5m
Efficient Algorithm3m
Problem Overview and Naive Algorithm4m
Efficient Algorithm5m
Computing Runtimes10m
Asymptotic Notation6m
Big-O Notation6m
Using Big-O10m
Course Overview10m

Practice exercises
Logarithms10m
Big-O10m
Growth rate10m

Programming Assignment: Programming Assignment 2: Algorithmic Warm-up

### Week 3. Greedy Algorithms

Largest Number3m
Queue of Patients11m
Implementation and Analysis7m
Main Ingredients of Greedy Algorithms1m
Celebration Party Problem3m
Greedy Algorithm5m
Implementation and Analysis5m
Maximizing Loot8m
Implementation and Analysis10m
Review4m

practice exercises
Largest Concatenate30m
Money Change30m
Puzzle: Balls in boxes30m
Puzzle: Activity Selection30m
Puzzle: Touch All Segments30m

Programming Assignment: Programming Assignment 3: Greedy Algorithms



### Week 4. Divide-and-Conquer
Linear Search7m
Binary Search7m
Binary Search Runtime8m
Problem Overview and Naïve Solution6m
Naïve Divide and Conquer Algorithm7m
Faster Divide and Conquer Algorithm6m
What is the Master Theorem?4m
Proof of the Master Theorem9m
Problem Overview2m
Selection Sort8m
Merge Sort10m
Lower Bound for Comparison Based Sorting12m
Non-Comparison Based Sorting Algorithms7m
Overview2m
Algorithm9m
Random Pivot13m
Running Time Analysis (optional)15m
Equal Elements6m
Final Remarks8m

practice exercises
Linear Search and Binary Search10m
Puzzle: 21 questions game30m
Puzzle: Two Adjacent Cells of Opposite Colors30m
Polynomial Multiplication15m
Master Theorem10m
Sorting15m
Quick Sort15m
Puzzle: Local Maximum30m

Programming Assignment: Programming Assignment 4: Divide and Conquer


### Week 5. Dynamic Programming 1
Change Problem10m
The Alignment Game8m
Computing Edit Distance6m
Reconstructing an Optimal Alignment4m

practice exercises
Change Money30m
Puzzle: Number of Paths30m
Puzzle: Two Rocks Game30m
Puzzle: Three Rocks Game30m
Edit Distance30m
Puzzle: Primitive Calculator30m

Programming Assignment: Programming Assignment 5: Dynamic Programming 1

### Week 6. Dynamic Programming 2
Knapsack with Repetitions10m
Knapsack without Repetitions18m
Final Remarks7m
Problem Overview7m
Subproblems6m
Algorithm12m
Reconstructing a Solution8m

practice exercises
Knapsack10m
Maximum Value of an Arithmetic Expression10m

Programming Assignment: Programming Assignment 6: Dynamic Programming 2

# Course 2. [Data Structures](https://www.coursera.org/learn/data-structures/home/week/1)

A good algorithm usually comes together with a set of good data structures that allow the algorithm to manipulate the data efficiently. In this online course, we consider the common data structures that are used in various computational problems. You will learn how these data structures are implemented in different programming languages and will practice implementing them in our programming assignments. This will help you to understand what is going on inside a particular built-in implementation of a data structure and what to expect from it. You will also learn typical use cases for these data structures.

A few examples of questions that we are going to cover in this class are the following:
1. What is a good strategy of resizing a dynamic array?
2. How priority queues are implemented in C++, Java, and Python?
3. How to implement a hash table so that the amortized running time of all operations is O(1) on average?
4. What are good strategies to keep a binary tree balanced? 

You will also learn how services like Dropbox manage to upload some large files instantly and to save a lot of storage space!

### Week 1.

### Week 2.

### Week 3.

### Week 4.


# Course 3. [Algorithms on Graphs](https://www.coursera.org/learn/algorithms-on-graphs/home/week/1)

If you have ever used a navigation service to find optimal route and estimate time to destination, you've used algorithms on graphs. Graphs arise in various real-world situations as there are road networks, computer networks and, most recently, social networks! If you're looking for the fastest time to get to work, cheapest way to connect a set of computers into a network or efficient algorithm to automatically find communities and opinion leaders in Facebook, you're going to work with graphs and algorithms on graphs.

In this online course, you will first learn what a graph is and what are some of the most important properties. Then you'll learn several ways to traverse graphs and how you can do useful things while traversing the graph in some order. We will then talk about shortest paths algorithms — from the basic ones to those which open door for 1000000 times faster algorithms used in Google Maps and other navigational services. You will use these algorithms if you choose to work on our Fast Shortest Routes industrial capstone project. We will finish with minimum spanning trees which are used to plan road, telephone and computer networks and also find applications in clustering and approximate algorithms.

### Week 1.

### Week 2.

### Week 3.

### Week 4.

# Course 4. [Algorithms on Strings](https://www.coursera.org/learn/algorithms-on-strings/home/week/1)

World and internet is full of textual information. We search for information using textual queries, we read websites, books, e-mails. All those are strings from the point of view of computer science. To make sense of all that information and make search efficient, search engines use many string algorithms. Moreover, the emerging field of personalized medicine uses many search algorithms to find disease-causing mutations in the human genome. In this online course you will learn key pattern matching concepts: tries, suffix trees, suffix arrays and even the Burrows-Wheeler transform.

### Week 1.

### Week 2.

### Week 3.

### Week 4.


# Course 5. [Advanced Algorithms and Complexity](https://www.coursera.org/learn/advanced-algorithms-and-complexity/home/week/1)

In previous courses of our online specialization you've learned the basic algorithms, and now you are ready to step into the area of more complex problems and algorithms to solve them. Advanced algorithms build upon basic ones and use new ideas. We will start with networks flows which are used in more typical applications such as optimal matchings, finding disjoint paths and flight scheduling as well as more surprising ones like image segmentation in computer vision. We then proceed to linear programming with applications in optimizing budget allocation, portfolio optimization, finding the cheapest diet satisfying all requirements and many others. Next we discuss inherently hard problems for which no exact good solutions are known (and not likely to be found) and how to solve them in practice. We finish with a soft introduction to streaming algorithms that are heavily used in Big Data processing. Such algorithms are usually designed to be able to process huge datasets without being able even to store a dataset.

### Week 1.

### Week 2.

### Week 3.

### Week 4.


# Course 6. [Genome Assembly Programming Challenge](https://www.coursera.org/learn/assembling-genomes/home/week/1)

In Spring 2011, thousands of people in Germany were hospitalized with a deadly disease that started as food poisoning with bloody diarrhea and often led to kidney failure. It was the beginning of the deadliest outbreak in recent history, caused by a mysterious bacterial strain that we will refer to as E. coli X. Soon, German officials linked the outbreak to a restaurant in Lübeck, where nearly 20% of the patrons had developed bloody diarrhea in a single week. At this point, biologists knew that they were facing a previously unknown pathogen and that traditional methods would not suffice – computational biologists would be needed to assemble and analyze the genome of the newly emerged pathogen.

To investigate the evolutionary origin and pathogenic potential of the outbreak strain, researchers started a crowdsourced research program. They released bacterial DNA sequencing data from one of a patient, which elicited a burst of analyses carried out by computational biologists on four continents. They even used GitHub for the project: https://github.com/ehec-outbreak-crowdsourced/BGI-data-analysis/wiki

The 2011 German outbreak represented an early example of epidemiologists collaborating with computational biologists to stop an outbreak. In this online course you will follow in the footsteps of the bioinformaticians investigating the outbreak by developing a program to assemble the genome of the E. coli X from millions of overlapping substrings of the E.coli X genome.


### Week 1.

### Week 2.

### Week 3.

### Week 4.